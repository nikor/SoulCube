<!-- 
A lot of this code was stolen from:
https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Basic_2D_animation_example
-->
<html>
<head>
<script id="vertex-shader" type="x-shader/x-vertex">
attribute vec2 aVertexPosition;
void main() {
    gl_Position = vec4(aVertexPosition, 0.0, 1.0);
}
</script>

<script id="fragment-shader" type="x-shader/x-fragment">
#ifdef GL_ES
    precision highp float;
#endif

uniform vec2 uSize;
uniform vec2 uScalingFactor;
uniform vec2 uTest[10];

void main() {
    vec2 nSize = vec2(
        gl_FragCoord.x/uSize.x - 0.5 + uTest[0].x,
        gl_FragCoord.y/uSize.y - 0.5 + uTest[0].y
    ) / uScalingFactor;
    float s = nSize.x * nSize.x + nSize.y * nSize.y;
    if (s < 0.001) {
        gl_FragColor = vec4(1.0 - s/0.001, 0.0, 0.0, 1.0);
    } else {
        gl_FragColor = vec4(0.7, 1.0, 0.5, 1.0);
    }
}
</script>

<script>
let inputState = ['A','S','D','W'].reduce((acc, x) => {
    acc['Key' + x] = false;
    return acc;
}, {});

let state = {
    playerPos: [0.0, 0.0]
};

let gl = null;
let glCanvas = null;

// Aspect ratio and coordinate system
// details

let aspectRatio;
let size;
let currentScale = [1.0, 1.0];

// Vertex information

let vertexArray;
let vertexBuffer;
let vertexNumComponents;
let vertexCount;


let objectArray;
let objectBuffer;

// Rendering data shared with the
// scalers.

let uScalingFactor;
let aVertexPosition;

// Animation timing

let previousTime = 0.0;
let degreesPerSecond = 90.0;
function buildShaderProgram(shaderInfo) {
    let program = gl.createProgram();

    shaderInfo.forEach(function(desc) {
        let shader = compileShader(desc.id, desc.type);

        if (shader) {
            gl.attachShader(program, shader);
        }
    });

    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.log("Error linking shader program:");
        console.log(gl.getProgramInfoLog(program));
    }
    return program;
}

function compileShader(id, type) {
    let code = document.getElementById(id).firstChild.nodeValue;
    let shader = gl.createShader(type);

    gl.shaderSource(shader, code);
    gl.compileShader(shader);

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.log(`Error compiling ${type === gl.VERTEX_SHADER ? "vertex" : "fragment"} shader:`);
        console.log(gl.getShaderInfoLog(shader));
    }
    return shader;
}

function startup() {
    glCanvas = document.getElementById("glcanvas");
    gl = glCanvas.getContext("webgl");

    const shaderSet = [
        { type: gl.VERTEX_SHADER,   id: "vertex-shader" },
        { type: gl.FRAGMENT_SHADER, id: "fragment-shader" }
    ];

    shaderProgram = buildShaderProgram(shaderSet);

    aspectRatio = glCanvas.width/glCanvas.height;
    size = [glCanvas.width, glCanvas.height];
    currentScale = [1.0, aspectRatio];

    //vertex stuff
    vertexArray = new Float32Array([ -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, -1, -1 ]);
    vertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertexArray, gl.STATIC_DRAW);
    vertexNumComponents = 2;
    vertexCount = vertexArray.length/vertexNumComponents;

    objectArray = new Float32Array([0.2, 0.2, 0.5, 0.5, 0.8, 0.8]);
    objectBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, objectBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, objectArray, gl.DYNAMIC_DRAW);

    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    aVertexPosition = gl.getAttribLocation(shaderProgram, "aVertexPosition");
    gl.enableVertexAttribArray(aVertexPosition);
    gl.vertexAttribPointer(aVertexPosition, vertexNumComponents, gl.FLOAT, false, 0, 0);
    //gl.drawArrays(gl.TRIANGLES, 0, vertexCount);
    animateScene();
}

var moveArray = [[1,0], [0,1], [-1,0], [0,-1]];
var keys = ['A','S','D','W'].map(x => 'Key' + x)
function animateScene() {
    keys.forEach((k,i) => {
        if (inputState[k]) {
            state.playerPos[0] += moveArray[i][0] * 0.01;
            state.playerPos[1] += moveArray[i][1] * 0.01;
        }
    });
    gl.viewport(0, 0, glCanvas.width, glCanvas.height);

    gl.useProgram(shaderProgram);
    uScalingFactor  = gl.getUniformLocation(shaderProgram, "uScalingFactor");
    uSize           = gl.getUniformLocation(shaderProgram, "uSize");
    uTest           = gl.getUniformLocation(shaderProgram, "uTest");

    gl.uniform2fv(uScalingFactor, currentScale);
    gl.uniform2fv(uSize, size);
    let data = [ 0.1, 0.1, 0.2, 0.2, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
    data[0] = state.playerPos[0];
    data[1] = state.playerPos[1];
    gl.uniform2fv(uTest, data);

    gl.drawArrays(gl.TRIANGLES, 0, vertexCount);

    window.requestAnimationFrame(function(currentTime) {
        previousTime = currentTime;
        animateScene();
    });
}

function getMousePos(canvas, evt) {
    var rect = canvas.getBoundingClientRect();
    return {
        x: evt.clientX - rect.left,
        y: evt.clientY - rect.top
    };
}
function mouseStartup() {
    glCanvas.addEventListener('mousemove', function(evt) {
        var mousePos = getMousePos(glCanvas, evt);
        var message = 'Mouse position: ' + mousePos.x + ',' + mousePos.y;
        console.log(message);
    }, false);
}

function keyBoardStarup() {
    var keys = ['A','S','D','W'].map(x => 'Key' + x)
    document.addEventListener('keydown', (e) => {
        if (-1 != keys.indexOf(e.code)) {
            console.log('down', e.code);
            inputState[e.code] = true;
        }
    });
    document.addEventListener('keyup', (e) => {
        if (-1 != keys.indexOf(e.code)) {
            inputState[e.code] = false;
            console.log('up', e.code);
        }
    });
}

function myStartup() {
    startup();
    mouseStartup();
    keyBoardStarup();
}

window.addEventListener("load", myStartup, false);
</script>
</head>
<body>
<canvas id="glcanvas" width="600" height="460">
    Oh no! Your browser doesn't support canvas!
</canvas>
</body>
</html>
